# 狼人杀游戏项目运行流程详解

## 📋 项目概述

这是一个基于 AgentScope 框架实现的九人狼人杀游戏，包含：
- 3名村民 👨‍🌾
- 3名狼人 🐺
- 1名预言家 🔮
- 1名女巫 🧙‍♀️
- 1名猎人 🏹

## 🚀 启动流程

### 1. 程序入口 (`main.py`)

#### 1.1 初始化阶段
```python
asyncio.run(main())
```

程序从 `main()` 异步函数开始执行：

1. **创建玩家智能体**
   - 创建9个 `ReActAgent` 实例，命名为 Player1 到 Player9
   - 每个智能体配置：
     - 系统提示词（包含游戏规则和角色指导）
     - 大语言模型（默认使用 DashScope 的 qwen2.5-32b-instruct）
     - 消息格式化器（DashScopeMultiAgentFormatter）

2. **加载检查点**
   - 从 `./checkpoints/players_checkpoint.json` 加载之前的游戏状态
   - 支持连续游戏，智能体可以从历史经验中学习

3. **启动游戏**
   - 调用 `werewolves_game(players)` 开始游戏主循环

4. **保存检查点**
   - 游戏结束后保存所有玩家状态到检查点文件

---

## 🎮 游戏主流程 (`game.py`)

### 2. 游戏初始化

#### 2.1 玩家状态管理
- 创建 `Players` 对象管理所有玩家状态
- 初始化女巫药水状态：`healing=True`, `poison=True`
- 设置首日标记：`first_day=True`

#### 2.2 角色分配
1. 向所有玩家广播游戏开始消息
2. 随机打乱玩家顺序和角色列表
3. 为每个玩家分配角色（私密通知）
4. 将玩家添加到 `Players` 管理器中
5. 打印角色分配结果（仅控制台可见）

---

### 3. 游戏主循环（最多30轮）

每一轮游戏分为 **夜晚阶段** 和 **白天阶段**：


## 🌙 夜晚阶段

### 3.1 狼人行动

#### 讨论环节
1. **创建狼人专属消息中心** (`MsgHub`)
   - 仅狼人可见的通信频道
   - 启用自动广播，狼人之间可以实时交流

2. **狼人讨论流程**
   - 最多进行 `MAX_DISCUSSION_ROUND * 狼人数量` 轮讨论（默认3轮/人）
   - 每个狼人轮流发言，使用 `DiscussionModel` 结构化输出
   - 如果 `reach_agreement=True`，提前结束讨论

3. **狼人投票**
   - 关闭自动广播（避免相互影响）
   - 使用 `fanout_pipeline` 并行收集所有狼人的投票
   - 每个狼人使用 `VoteModel` 结构化输出选择目标
   - 通过 `majority_vote()` 统计投票结果
   - 广播投票消息和结果

**输出**: `killed_player` - 被狼人选中的目标

---

### 3.2 女巫行动

#### 解药环节
1. 向所有存活玩家广播"女巫回合"
2. 如果女巫还有解药 (`healing=True`) 且被杀者不是女巫自己：
   - 告知女巫被杀玩家的名字
   - 女巫使用 `WitchResurrectModel` 决定是否救人
   - 如果 `resurrect=True`：
     - 将 `killed_player` 设为 `None`
     - 标记 `healing=False`（解药已用）

#### 毒药环节
1. 如果女巫还有毒药 (`poison=True`) 且本回合未使用解药：
   - 询问女巫是否使用毒药
   - 女巫使用 `PoisonModel` 决定是否毒人及目标
   - 如果 `poison=True`：
     - 记录 `poisoned_player`
     - 标记 `poison=False`（毒药已用）

**输出**: `poisoned_player` - 被女巫毒死的玩家（可能为None）

---

### 3.3 预言家行动

1. 向所有存活玩家广播"预言家回合"
2. 预言家使用 `SeerModel` 选择要查验的玩家
3. 系统私密告知预言家该玩家的真实身份
4. 仅预言家可见此信息

**输出**: 预言家获得一名玩家的身份信息

---

### 3.4 猎人夜晚技能

1. 检查猎人是否在夜晚被杀（且不是被女巫毒死）
2. 如果条件满足：
   - 调用 `hunter_stage()` 函数
   - 猎人使用 `HunterModel` 决定是否开枪及目标
   - 如果 `shoot=True`，记录 `shot_player`

**输出**: `shot_player` - 被猎人带走的玩家（可能为None）

---

### 3.5 夜晚结算

1. **更新玩家状态**
   - 汇总夜晚死亡名单：`[killed_player, poisoned_player, shot_player]`
   - 调用 `players.update_players()` 移除死亡玩家

2. **广播夜晚结果**
   - 如果有人死亡：广播死亡玩家名单
   - 如果是首夜且有玩家被杀：允许被杀玩家留遗言
   - 如果平安夜：广播"昨晚平安"

---

## ☀️ 白天阶段

### 3.6 胜利检查（第一次）

调用 `players.check_winning()` 检查游戏是否结束：
- **狼人胜利条件**: 狼人数量 × 2 ≥ 存活玩家数量
- **村民胜利条件**: 所有狼人被淘汰

如果游戏结束，广播胜利消息并退出循环。

---

### 3.7 白天讨论

1. **广播讨论开始**
   - 告知所有存活玩家当前局势
   - 按顺序列出发言顺序

2. **顺序发言**
   - 启用消息中心的自动广播
   - 使用 `sequential_pipeline` 让玩家依次发言
   - 每个玩家可以分析局势、表明立场、指控他人

3. **关闭自动广播**
   - 讨论结束后关闭，准备投票

---

### 3.8 白天投票

1. **并行收集投票**
   - 使用 `fanout_pipeline` 同时向所有存活玩家请求投票
   - 每个玩家使用 `VoteModel` 选择要淘汰的目标
   - 关闭自动广播避免相互影响

2. **统计投票结果**
   - 通过 `majority_vote()` 确定被投票淘汰的玩家
   - 准备投票消息列表

3. **遗言环节**
   - 如果有玩家被投票淘汰
   - 允许该玩家发表最后遗言
   - 将遗言添加到投票消息列表

4. **广播投票结果**
   - 一次性广播所有投票消息、结果和遗言

**输出**: `voted_player` - 被投票淘汰的玩家

---

### 3.9 猎人白天技能

1. 检查被投票淘汰的玩家是否是猎人
2. 如果是猎人：
   - 调用 `hunter_stage()` 函数
   - 猎人使用 `HunterModel` 决定是否开枪及目标
   - 如果开枪，广播猎人带走的玩家

**输出**: `shot_player` - 被猎人带走的玩家（可能为None）

---

### 3.10 白天结算

1. **更新玩家状态**
   - 汇总白天死亡名单：`[voted_player, shot_player]`
   - 调用 `players.update_players()` 移除死亡玩家

2. **胜利检查（第二次）**
   - 再次调用 `players.check_winning()`
   - 如果游戏结束：
     - 向所有玩家（包括死亡玩家）广播结果
     - 公布所有玩家的真实身份
     - 退出游戏循环

3. **回合结束**
   - 设置 `first_day=False`
   - 进入下一轮游戏

---

## 🎯 游戏结束

### 4. 反思阶段

游戏结束后，所有玩家（包括死亡玩家）进行反思：
- 使用 `fanout_pipeline` 并行向所有玩家发送反思提示
- 每个玩家分析自己的表现
- 反思内容仅玩家自己可见

---

## 🔧 核心技术组件

### 5.1 消息中心 (`MsgHub`)

用于管理不同范围的消息广播：
- **全体存活玩家频道**: 白天讨论和投票
- **狼人专属频道**: 夜晚狼人讨论
- **全体玩家频道**: 游戏结束时的总结

特性：
- 支持自动广播和手动广播切换
- 支持消息批量广播
- 支持私密通信

### 5.2 管道 (`Pipeline`)

- **sequential_pipeline**: 顺序执行，用于白天讨论
- **fanout_pipeline**: 并行执行，用于投票和反思

### 5.3 结构化输出 (`structured_model.py`)

使用 Pydantic 模型确保智能体输出格式正确：

| 模型 | 用途 | 字段 |
|------|------|------|
| `DiscussionModel` | 狼人讨论 | `reach_agreement: bool` |
| `VoteModel` | 投票 | `vote: Literal[玩家名]` |
| `WitchResurrectModel` | 女巫解药 | `resurrect: bool` |
| `WitchPoisonModel` | 女巫毒药 | `poison: bool`, `name: str\|None` |
| `SeerModel` | 预言家查验 | `name: Literal[玩家名]` |
| `HunterModel` | 猎人开枪 | `shoot: bool`, `name: str\|None` |

### 5.4 玩家管理 (`Players` 类)

维护游戏状态：
- `name_to_role`: 玩家名到角色的映射
- `role_to_names`: 角色到玩家名列表的映射
- `name_to_agent`: 玩家名到智能体对象的映射
- `current_alive`: 当前存活玩家列表
- 各角色专属列表：`werewolves`, `villagers`, `seer`, `witch`, `hunter`

核心方法：
- `add_player()`: 添加玩家
- `update_players()`: 更新存活状态
- `check_winning()`: 检查胜利条件

---

## 📊 数据流图

```
启动 (main.py)
    ↓
创建9个智能体
    ↓
加载检查点 (可选)
    ↓
游戏初始化 (game.py)
    ├─ 角色分配
    └─ 创建Players管理器
    ↓
┌─────────────────────────┐
│   游戏主循环 (最多30轮)   │
├─────────────────────────┤
│  🌙 夜晚阶段             │
│    ├─ 狼人讨论+投票      │
│    ├─ 女巫解药/毒药      │
│    ├─ 预言家查验         │
│    ├─ 猎人技能(可能)     │
│    └─ 夜晚结算           │
│         ↓                │
│    胜利检查 ──→ 结束?    │
│         ↓ 否             │
│  ☀️ 白天阶段             │
│    ├─ 白天讨论           │
│    ├─ 投票+遗言          │
│    ├─ 猎人技能(可能)     │
│    └─ 白天结算           │
│         ↓                │
│    胜利检查 ──→ 结束?    │
│         ↓ 否             │
│    下一轮 ←──────────────┤
└─────────────────────────┘
    ↓ 是
游戏结束
    ↓
玩家反思
    ↓
保存检查点
    ↓
程序退出
```

---

## 🎲 关键决策点

### 投票机制
- 使用 `majority_vote()` 函数统计票数
- 返回得票最多的玩家和详细票数分布

### 胜利判定
1. **狼人胜利**: `len(werewolves) * 2 >= len(current_alive)`
2. **村民胜利**: `len(werewolves) == 0 and len(current_alive) > 0`

### 特殊规则
- 女巫不能自救
- 女巫同一夜不能同时使用解药和毒药
- 猎人被毒死不能开枪
- 首夜被杀玩家可以留遗言
- 被投票淘汰的玩家可以留遗言

---

## 🔄 状态持久化

### 检查点系统
- **保存位置**: `./checkpoints/players_checkpoint.json`
- **保存内容**: 所有玩家的对话历史和状态
- **用途**: 支持连续游戏，智能体可以从历史中学习

### 会话管理
使用 `JSONSession` 管理游戏状态：
```python
session = JSONSession(save_dir="./checkpoints")
await session.load_session_state(...)  # 加载
await session.save_session_state(...)  # 保存
```

---

## 🌐 多语言支持

项目支持中英文双语：
- **英文**: `from prompt import EnglishPrompts as Prompts`
- **中文**: `from prompt import ChinesePrompts as Prompts`

所有游戏提示词都在 `prompt.py` 中定义。

---

## 🛠️ 配置选项

### 可调参数 (`utils.py`)
- `MAX_GAME_ROUND = 30`: 最大游戏轮数
- `MAX_DISCUSSION_ROUND = 3`: 每个狼人的最大讨论轮数

### 模型配置 (`main.py`)
支持多种大语言模型：
- **DashScope**: qwen2.5-32b-instruct
- **OpenAI**: glm-4.5-air (智谱AI)
- **Ollama**: qwen2.5:1.5b (本地模型)

只需修改 `get_official_agents()` 函数中的注释即可切换。

---

## 📝 总结

整个游戏流程是一个精心设计的多智能体协作系统：
1. **异步执行**: 使用 asyncio 实现高效的并发处理
2. **结构化输出**: 确保智能体行为可控和可预测
3. **消息管理**: 通过 MsgHub 实现复杂的通信模式
4. **状态管理**: Players 类统一管理游戏状态
5. **持久化**: 支持游戏状态的保存和加载

这个项目展示了如何使用 AgentScope 框架构建复杂的多智能体游戏系统。
